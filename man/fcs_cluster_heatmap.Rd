% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fcs_cluster_heatmap.R
\name{fcs_cluster_heatmap}
\alias{fcs_cluster_heatmap}
\title{Generate Cluster Heatmap for Flow Cytometry Data}
\usage{
fcs_cluster_heatmap(
  fcs_join_obj,
  algorithm,
  include_parameters = "all",
  include_clusters = "all",
  heatmap_color_palette = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  transpose_heatmap = FALSE,
  cluster_row = TRUE,
  cluster_col = TRUE,
  override_correction = TRUE,
  return_heatmap_data = FALSE,
  heatmap_linewidth = 0.5
)
}
\arguments{
\item{fcs_join_obj}{A list returned by FCSimple::fcs_join() and FCSimple::fcs_cluster(),
containing at least:
- `data`: numeric matrix of events × channels
- `<algorithm>$clusters`: vector of cluster IDs per event
- optionally `batch_correction$data` if correction was applied}

\item{algorithm}{Character; name of clustering results in `fcs_join_obj` to use
(e.g. `"leiden"`, `"flowsom"`, etc.).}

\item{include_parameters}{Character vector of channel names to include (default `"all"`).
If `"all"`, uses all columns of the expression matrix.}

\item{include_clusters}{Character vector of cluster IDs to include (default `"all"`).
If `"all"`, includes every cluster.}

\item{heatmap_color_palette}{Character vector of colors (length ≥ 2) for the heatmap palette.
Default uses a reversed “RdYlBu” from RColorBrewer.}

\item{transpose_heatmap}{Logical; if `TRUE`, transpose the heatmap matrix before plotting.
Default `FALSE`.}

\item{cluster_row}{Logical; if `TRUE`, apply hierarchical clustering to rows.
Default `TRUE`.}

\item{cluster_col}{Logical; if `TRUE`, apply hierarchical clustering to columns.
Default `TRUE`.}

\item{override_correction}{Logical; if `TRUE`, always use raw data even if batch correction
is present. Default `TRUE`.}

\item{return_heatmap_data}{Logical; if `TRUE`, return the matrix of median‐scaled values
invisibly instead of adding the heatmap to `fcs_join_obj`.
Default `FALSE`.}

\item{heatmap_linewidth}{Numeric; border line width for heatmap cells. Default `0.5`.}
}
\value{
Invisibly returns the updated `fcs_join_obj` with a new element
  `<algorithm>_heatmap` as described above. If
  `return_heatmap_data = TRUE`, returns only the heatmap matrix.
}
\description{
Computes and visualizes median‐scaled expression of each cluster across
  parameters using ComplexHeatmap. Selects raw or batch‐corrected data,
  aggregates by cluster, and stores both the heatmap object and tile data.
}
\details{
- Chooses raw or batch‐corrected data based on `override_correction` and
  presence of `fcs_join_obj$batch_correction$data`.  
- Scales expression values to [0,1] per channel using
  CATALYST:::.scale_exprs.  
- Computes median expression for each cluster × parameter.  
- Builds a ComplexHeatmap object with cluster‐size annotations.  
- Stores the result under
  `fcs_join_obj[[paste0(tolower(algorithm), "_heatmap")]]`:
    - `heatmap`: the Heatmap object  
    - `heatmap_tile_data`: the numeric matrix used  
    - `population_size`: cluster event counts  
    - `rep_used`: “with batch correction” or “without batch correction”  
- Appends a timestamped entry to `object_history`.
}
\examples{
\dontrun{
  joined <- FCSimple::fcs_join(list(ff1, ff2))
  clustered <- FCSimple::fcs_cluster(joined, algorithm = "leiden")

  # Generate and store heatmap object
  out <- FCSimple::fcs_cluster_heatmap(
    clustered,
    algorithm = "leiden",
    include_parameters = c("CD3","CD4","CD8"),
    override_correction = FALSE
  )

  # Just get the tile matrix
  mat <- FCSimple::fcs_cluster_heatmap(
    clustered,
    algorithm = "leiden",
    return_heatmap_data = TRUE
  )
}

}
\seealso{
FCSimple::fcs_cluster, FCSimple::fcs_plot_heatmap
}
